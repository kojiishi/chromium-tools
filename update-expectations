#!/usr/bin/env node
'use strict';
const assert = require('assert');
const child_process = require('child_process');
const fs = require('fs-extra');
const https = require('https');
const path = require('path');

let log = () => {};
const statistics = {
  LinesChanged: 0,
  LinesAdded: 0,
  LinesRemoved: 0,
};
let async_tasks = [];
let options;

function parseArgs(args) {
  const minimist = require('minimist');
  args = args || process.argv.slice(2);
  const options = minimist(args, {
    boolean: ['deflake', 'deflake-all', 'no-commit', 'remove', 'sort', 'verbose'],
    string: ['bug', 'expects', 'file', 'path', 'rebaseline'],
    alias: {
      b: 'bug',
      d: 'deflake',
      D: 'deflake-all',
      e: 'expects',
      f: 'file',
      n: 'no-commit',
      p: 'path',
      r: 'rebaseline',
      s: 'sort',
      v: 'verbose',
    },
    default: {
      expects: '*',
    },
    unknown: arg => {
      if (arg.startsWith('-')) {
        throw new Error(`Unknown option ${arg}
Usage: ${path.basename(__filename)} [options] [results.json...]
  -b <bug>: The bug number/string for new entries.
  -d: De-flake if all results are pass.
  -D: De-flake if all results are consistent.
  -e <expect,expect,...>: Update specified expects only.
     If the expect starts with '-', it is ignored instead.
  -f <file>: The TestExpectations file path.
  -p <string>: Only include tests with the specified path.
     If the path starts with '-', it is excluded instead.
  -r <test paths>: Rebaseline specified tests instead of adding to expectations.
     Test paths is space or newline delimited string.
     When it's '-', it's read from stdin.
  --remove: Remove entries where test files are missing in the local file system.
  -s: Sort the output.
  -v: Verbose.
`);
      }
      return true;
    },
  });
  if (options.verbose)
    log = console.log.bind(console);
  log.files = [];
  log.warnings = [];
  log.warn = msg => {
    log(msg);
    log.warnings.push(msg);
  };
  if (options.bug && options.bug.match(/^\d/))
    options.bug = 'crbug.com/' + options.bug;
  options.expects = (args => {
    if (!args.length)
      return {};
    if (args[0][0] === '-')
      args = ['*'].concat(args);
    let expects = {};
    for (let arg of args) {
      if (arg === '*') {
        for (let e of ['Pass', 'Failure', 'Crash', 'Timeout'])
          expects[e] = 0;
      } else if (arg[0] === '-') {
        delete expects[arg.slice(1)];
      } else {
        expects[arg] = 0;
      }
    }
    return expects;
  })(argAsArray(options.expects));
  options.shouldUpdate = (args => {
    if (!args.length)
      return () => true;
    return testPath => {
      let whenNotFound = true;
      for (let arg of args) {
        if (arg.startsWith('-')) {
          if (testPath.includes(arg.slice(1)))
            return false;
        } else {
          if (testPath.includes(arg))
            return true;
          whenNotFound = false;
        }
      }
      return whenNotFound;
    };
  })(argAsArray(options.path));
  options.shouldRebaseline = (args => {
    if (!args.length)
      return () => false;
    let byPath = arrayToDict(args);
    return testPath => testPath in byPath;
  })(argAsArray(options.rebaseline));
  return options;
}

function argAsArray(arg) {
  if (!arg)
    return [];
  if (arg === '-')
    arg = fs.readFileSync('/dev/stdin').toString();
  if (!Array.isArray(arg))
    arg = arg.split(/[, \n]/).filter(p => p);
  return arg;
}

function arrayToDict(array, value = true) {
  let dict = {};
  for (let i of array)
    dict[i] = value;
  return dict;
}

function parseTryResults(lines) {
  let state = '';
  let args = [];
  for (let line of lines) {
    let match = line.match(/^(\S+):$/);
    if (match) {
      state = match[1];
      continue;
    }
    match = line.match(/^\s+(\S+)\s+\S+\/(\d+)$/);
    if (match) {
      if (state !== 'Started')
        args.push(match[2]);
      continue;
    }
    log(`Unrecognized line ignored: ${line}`);
  }
  return args;
}

function downloadUrl(url, dest) {
  log(`Downloading from ${url}`);
  return new Promise((resolve, reject) => {
    let created = null;
    https.get(url, response => {
      log(`HTTP Status=${response.statusCode} for ${url}`);
      if (response.statusCode != 200) {
        reject(new Error(`HTTP status ${response.statusCode}`));
        return;
      }
      let dirname = path.dirname(dest);
      if (dirname)
        fs.ensureDirSync(dirname);
      let output = fs.createWriteStream(dest);
      created = dest;
      response.pipe(output);
      output.on('finish', () => {
        log(`Download completed to ${dest}.`);
        output.close(resolve);
      });
    }).on('error', err => {
      if (created)
        fs.unlink(created);
      reject(err);
    });
  });
}

class TestExpectation {
  constructor(bug, testPath, expectations = [], conditions, trailing) {
    this.bug = bug;
    this.path = testPath;
    this.expectations = expectations;
    this.conditions = conditions;
    this.trailing = trailing;
    this.isRemoved = false;
    this.confirmedExpectations = {};
    this.shouldNotUpdate = (this.expectations.length == 1 &&
                             (this.expectations[0] == 'Skip' ||
                              this.expectations[0] == 'NeedsRebaseline' ||
                              this.expectations[0] == 'NeedsManualRebaseline'));
  }

  static parse(line) {
    if (line.expectations)
      return line;
    let match = line.match(/^(\S*)\s+(\[([^\]]+)]\s+)?(\S+)\s+\[([^\]]+)](.*)/);
    if (match) {
      return new TestExpectation(match[1], match[4], match[5].trim().split(/\s+/), match[3], match[6]);
    }
    return null;
  }

  static isTestExpectation(obj) {
    return obj instanceof TestExpectation;
  }

  get filePath() {
    return this.path.replace(/^virtual\/[^/]*\//, '');
  }

  toString() {
    if (this.isRemoved)
      return null;
    let output = [ this.bug ? this.bug : '' ];
    if (this.conditions)
      output = output.concat('[', this.conditions.trim(), ']');
    output = output.concat(this.path, '[', this.expectations, ']');
    return output.join(' ') + (this.trailing ? this.trailing : '');
  }

  remove() {
    assert(!this.isRemoved);
    this.isRemoved = true;
    statistics.LinesRemoved++;
  }

  updateExpectations(result) {
    //log(`${this.path}: ${result.actual}`);
    if (this.shouldNotUpdate)
      return 0;
    let is_unexpected = result.is_unexpected;
    let expects = result.actual.split(/ +/).map(actual => {
      switch (actual) {
        case 'PASS':
          return 'Pass';
        case 'IMAGE':
        case 'TEXT':
        case 'IMAGE+TEXT':
          return 'Failure';
        case 'CRASH':
          return 'Crash';
        case 'TIMEOUT':
          return 'Timeout';
        case 'MISSING':
          return 'Skip';
        case 'SKIP':
          return null;
        default:
          throw new Error(`Unknown actual ${actual}`);
      }
    }).filter(expect => expect != null);
    let addCount = 0;
    for (let expect of expects) {
      this.confirmedExpectations[expect] = true;
      if (is_unexpected && expect in statistics && !this.expectations.includes(expect)) {
        log(`  Adding ${expect} to ${this.path}`);
        this.expectations.push(expect);
        statistics[expect]++;
        addCount++;
      }
    }
    if (addCount) {
      this.expectations.sort();
      statistics.LinesChanged++;
    }
    return addCount;
  }

  rebaseline(result, results) {
    let actuals = result.actual.split(/ +/);
    if (actuals.length !== 1) {
      log.warn(`  Ignore rebaseline due to flaky: ${this.path}`);
      return false;
    }
    let testPath = path.parse(this.path);
    let refPath = path.join(results.testRootDir, testPath.dir, testPath.name + '-expected' + testPath.ext);
    if (fs.existsSync(refPath)) {
      log.warn(`  Ignore rebaseline of ref test: ${this.path}`);
      return false;
    }
    let name = this.path.replace(/\.[a-z]+$/, '');
    log(`  Rebaseline ${actuals[0]} for ${this.path}`);
    let downloads = [];
    for (let type of actuals[0].split('+')) {
      let ext = null;
      switch (type) {
        case 'IMAGE':
          ext = '.png';
          break;
        case 'TEXT':
          ext = '.txt';
          break;
        default:
          log.warn(`  Cannot rebaseline '${actuals.join(' ')}: ${this.path}`);
          return false;
      }
      let source = results.sourceDir + name + '-actual' + ext;
      let dest = path.join(results.rebaselineDir, name + '-expected' + ext);
      downloads.push(downloadUrl(source, dest)
        .then(() => log.files.push(dest)));
    }
    async_tasks.push(Promise.all(downloads)
      .then(() => this.remove()));
    return true;
  }

  deflake(deflakeAll) {
    if (this.shouldNotUpdate)
      return false;
    let confirmCount = Object.keys(this.confirmedExpectations).length;
    if (!confirmCount)
      return false;

    if (confirmCount == 1 && this.confirmedExpectations['Pass']) {
      // Don't remove '[ Pass ]', it's to override expectations in different expectations file.
      if (this.expectations.length == 1 && this.expectations[0] == 'Pass')
        return true;

      log(`  Removing all passes: ${this.path}`);
      this.remove();
      return true;
    }

    if (!deflakeAll)
      return;
    let deflaked = this.expectations.filter(e => e in this.confirmedExpectations);
    assert(deflaked.length <= this.expectations.length);
    if (deflaked.length === this.expectations.length)
      return false;
    if (deflaked.length) {
      log(`  Deflaking from ${this.expectations} to ${deflaked}: ${this.path}`);
      this.expectations = deflaked;
    } else {
      log.warn(`  Deflaking from ${this.expectations} to ${deflaked} using results ${Object.keys(this.confirmedExpectations)}: ${this.path}`);
      this.remove();
    }
    statistics.LinesDeflaked = statistics.LinesDeflaked || 0;
    statistics.LinesDeflaked++;
    return true;
  }

  exists(testRoot) {
    return fs.existsSync(path.resolve(testRoot, this.filePath));
  }
}

class TestExpectations {
  constructor(file) {
    this.path = file;
    log(`Reading expectations file from ${file}`);
    let inputText = fs.readFileSync(file, 'utf8');
    this.parse(inputText);
  }

  parse(inputText) {
    let lines = inputText.trimRight().split(/\r?\n/)
    let tests = [];
    this.testByPath = {};
    for (let line of lines) {
      let test = TestExpectation.parse(line);
      if (!test) {
        tests.push(line);
      } else {
        tests.push(test);
        this.testByPath[test.path] = test;
      }
    }
    this.lines = tests;
  }

  write() {
    let lines = this.lines
      .filter(test =>
        !TestExpectation.isTestExpectation(test) ||
        !test.isRemoved);
    fs.writeFileSync(this.path, lines.join('\n') + '\n', 'utf8');
  }

  get expectations() {
    return this.lines.filter(test =>
      TestExpectation.isTestExpectation(test) && !test.isRemoved);
  }

  expectation(testPath) {
    assert(testPath);
    return this.testByPath[testPath];
  }

  add(test) {
    assert(TestExpectation.isTestExpectation(test) && !test.isRemoved);
    this.lines.push(test);
    this.testByPath[test.path] = test;
    statistics.LinesAdded++;
  }

  deflake(deflakeAll) {
    log(`De-flaking ${deflakeAll ? 'all results' : 'passes'}`);
    for (let test of this.expectations) {
      test.deflake(deflakeAll);
    }
  }

  removeIfNotExists(testRootDir) {
    if (!testRootDir)
      testRootDir = TestExpectations.findTestRootDir(this.path);
    log(`Checking non-existent tests in ${testRootDir}`);
    return this.removeIf(test => {
      if (test.path && !test.exists(testRootDir)) {
        log(`  Removing non-existent test: ${test.path}`);
        statistics.LinesRemoved++;
        return true;
      }
      return false;
    });
  }

  sort() {
    let input = this.lines;
    let output = [];
    let comparer = (a, b) => {
      assert.notEqual(a.path, b.path);
      return a.path < b.path ? -1 : 1;
    };
    while (input.length) {
      let i = 0;
      for (; i < input.length; i++)
        if (TestExpectation.isTestExpectation(input[i]))
          break;
      if (i) {
        output = output.concat(input.slice(0, i));
        input = input.slice(i);
      }
      i = 0;
      for (; i < input.length; i++)
        if (!TestExpectation.isTestExpectation(input[i]))
          break;
      if (i) {
        let tests = input.slice(0, i);
        tests.sort(comparer);
        output = output.concat(tests);
        input = input.slice(i);
      }
    }
    this.lines = output;
  }

  static findTestRootDir(dir) {
    // Traverse ancestor directories to find the test root.
    for (dir = dir || '.';;) {
      if (fs.existsSync(path.resolve(dir, 'TestExpectations')))
        return dir;
      let parent = path.resolve(dir, '..');
      if (parent == dir)
        return null;
      dir = parent;
    }
  }
}

class TestResults {
  constructor(results, sourcePath) {
    this.results = results;
    this.sourcePath = sourcePath;
    this.sourceDir = path.dirname(sourcePath) + '/';
  }

  static async load(file = TestResults.defaultPath) {
    // If this is a build#, download from the layout-test-archive.
    let sourcePath = file;
    if (/^[0-9]+$/.test(file) && !fs.existsSync(file)) {
      let build = file;
      sourcePath = `https://storage.googleapis.com/chromium-layout-test-archives/linux_layout_tests_layout_ng/${build}/layout-test-results/full_results.json`;
      file = path.join(process.env.HOME, 'ng-bot', build + '.json');
      if (!fs.existsSync(file)) {
        await downloadUrl(sourcePath, file);
      }
    }

    log(`Loading results from ${file}`);
    let content = fs.readFileSync(file, 'utf8');
    // Convert "ADD_RESULTS({...});" to a normal JSON.
    content = content.replace(/^[A-Z_]*\(/, '');
    content = content.replace(/\);$/, '');
    return new TestResults(JSON.parse(content), sourcePath);
  }

  get message() {
    if (this.results.build_number)
      return this.results.build_number;
    return this.sourcePath;
  }

  get regressionCount() {
    return this.results.num_regressions;
  }

  get testRootDir() {
    if (this._testRootDir)
      return this._testRootDir;

    // Try the directory in results JSON.
    // It may not exist if the JSON is produced in other machines.
    this._testRootDir = this.results.layout_tests_dir;
    if (fs.existsSync(this._testRootDir)) {
      log(`Test root directory: ${this._testRootDir}`);
      return this._testRootDir;
    }

    this._testRootDir = TestExpectations.findTestRootDir();
    if (this._testRootDir) {
      log(`Test root directory: ${this._testRootDir}`);
      return this._testRootDir;
    }

    throw new Error('Test root directory not found');
  }

  get rebaselineDir() {
    let dir = this.testRootDir;
    dir = path.join(dir, 'flag-specific', 'enable-blink-features=LayoutNG');
    return dir;
  }

  toString() {
    if (this.results.builder_name)
      return `${this.results.build_number}@${this.results.builder_name}`;
    return `local (${this.sourcePath})`;
  }

  result(testPath) {
    let result = this.results.tests;
    for (let name of testPath.split(/\//)) {
      result = result[name];
      if (!result)
        return null;
    }
    if (!result.actual) {
      // Skip entry for a directory.
      log(`  Skipping ${testPath} because actual is missing`);
      return null;
    }
    return result;
  }

  updateExpectations(expectations) {
    log(`Updating expectations from ${this.toString()}`);
    this.updateExpectationsRecursively(expectations, this.results.tests, '');
  }

  updateExpectationsRecursively(expectations, result, testPath) {
    // If this is a directory, traverse children.
    if (!result.actual) {
      for (let name in result) {
        this.updateExpectationsRecursively(expectations, result[name], testPath ? testPath + '/' + name : name);
      }
      return;
    }

    // If this is a test result, update expectations.
    assert(testPath);
    let shouldUpdate = options.shouldUpdate(testPath);
    let shouldRebaseline = options.shouldRebaseline(testPath);
    if (!shouldUpdate && !shouldRebaseline)
      return;
    let test = expectations.expectation(testPath);
    let isNew = !test;
    if (isNew)
      test = new TestExpectation(options.bug, testPath);
    if (shouldRebaseline) {
      test.rebaseline(result, this);
      return;
    }
    if (shouldUpdate)
      test.updateExpectations(result);
    if (isNew && test.expectations.length)
      expectations.add(test);
  }

  static get defaultPath() {
    const outDir = process.env.CHROMIUM_OUTPUT_DIR;
    return path.resolve(outDir, 'layout-test-results', 'full_results.json');
  }
}

async function run(args) {
  let expectations = options.file ? new TestExpectations(options.file) : null;
  log(`Checking test results for: ${Object.keys(options.expects).join(', ')}`);
  for (let key of Object.keys(options.expects))
    statistics[key] = 0;

  if (!args.length) {
    let lines = fs.readFileSync('/dev/stdin').toString().split(/\n/);
    args = parseTryResults(lines);
  }
  log(`Loading results: ${args.join(' ')}`);
  args = args.map(arg => TestResults.load(arg));
  let messages = [];
  for (let results of args) {
    results = await results;
    if (!expectations)
      expectations = new TestExpectations(path.resolve(results.testRootDir, 'TestExpectations'));
    results.updateExpectations(expectations);
    messages.push(results.message);
  }

  let summary = ['Update summary:'];
  if (options.remove) {
    let missingTests = expectations.removeIfNotExists();
    summary.push(`  Removed due to missing tests: ${missingTests}`);
  }
  if (options.deflake || options['deflake-all']) {
    expectations.deflake(options['deflake-all']);
  }

  if (async_tasks.length) {
    log('Waiting for all rebaseline tasks to copmlete');
    await Promise.all(async_tasks);
  }

  if (log.warnings.length) {
    log('WARNINGS:');
    for (let warning of log.warnings)
      log(warning);
  }
  let changeCount = 0;
  for (let key in statistics) {
    let value = statistics[key];
    changeCount += value;
    summary.push(`  ${key}: ${value}`);
  }
  log(summary.join('\n'));

  if (options.sort)
    expectations.sort();
  expectations.write();
  log.files.push(expectations.path);

  if (log.files.length) {
    log(`git: Adding ${log.files.length} files`);
    child_process.spawnSync('git', ['add'].concat(log.files), { stdio: 'inherit' });
    if (!options['no-commit'])
      child_process.spawnSync('git', ['commit', '-m', messages.join(' ')], { stdio: 'inherit' });
  }
}

if (require.main === module) {
  options = parseArgs();
  run(options._).catch(err => {
    console.log(err);
    process.exit(1);
  });
} else {
  module.exports = run;
  module.exports.parseArgs = parseArgs;
  module.exports.parseTryResults = parseTryResults;
  module.exports.TestResults = TestResults;
  module.exports.TestExpectations = TestExpectations;
}
