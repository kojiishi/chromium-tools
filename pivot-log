#!/usr/bin/env node
//
// This tool generates a pivot table report from multiple runs of a program.
//
// Firt, add counters to the code. A counter is a line in stderr that starts
// with "++" prefix. E.g., the following line adds "Counter1" counter:
//
//   LOG(INFO) << "++Counter1";
//
// then run this tool:
//
//   % pivot-log -nt http://www.google.com
//
// The tool runs `content_shell` twice with different arguments, collects
// lines that start with "++" from stderr and generates a report like this:
//
//   Counter1: legacy=12 ng=15
//   Counter2: legacy=15 ng=15
//
// A sample log code at:
// https://chromium-review.googlesource.com/c/chromium/src/+/1455836
//
const child_process = require('child_process');
const fs = require('fs');
const path = require('path');

class PivotLog {
  async run() {
    let args = process.argv.slice(2);
    const minimist = require('minimist');
    this.options = minimist(args, {
      boolean: ['all', 'ng', 'test', 'verbose'],
      alias: {
        a: 'all',
        n: 'ng',
        t: 'test',
        v: 'verbose',
      },
    });
    args = this.options._;
    this.verbose = this.options.verbose ?
        console.log.bind(console) : () => {};

    if (this.options.ng) {
      this.compare(args);
      return;
    }

    await this.pivot(args);
  }

  async compare(args) {
    let command = path.join(process.env.OUT, 'content_shell');
    let command_args0 = [];
    if (this.options.test)
      command_args0.push('--run-web-tests');
    let command_args = {
      legacy: command_args0,
      ng: [...command_args0, '--enable-blink-features=LayoutNG'],
    };

    for (let arg of args) {
      let processes = Object.entries(command_args)
          .map(entry => this.collect(entry[0], command, [...entry[1], arg]));
      let logs;
      if (this.options.test) {
        logs = await Promise.all(processes);
      } else {
        logs = [];
        for (let p of processes)
          logs.push(await p);
      }
      await this.pivot(logs, arg);
    }
  }

  async collect(name, command, args) {
    return new Promise((resolve, reject) => {
      let logpath = name + '.log';
      const p = child_process.spawn(command, args, {
        stdio: ['inherit', 'ignore', 'pipe'],
        shell: false,
      });
      const log = fs.createWriteStream(logpath);
      p.stderr.pipe(log);
      p.on('close', (code) => {
        resolve(logpath);
      });
    });
  }

  async parse(file) {
    let content = fs.readFileSync(file, 'utf8');
    let re_inc = new RegExp(/^\[[^]*] \+\+(\S+)/);
    let re_assign = new RegExp(/^\[[^]*] ([^ ][^=]*)=(\d+)$/);
    let kv = {};
    for (let line of content.split(/\r?\n/)) {
      let match = re_inc.exec(line);
      if (match) {
        let key = match[1];
        let value = kv[key];
        kv[key] = value ? value + 1 : 1;
        continue;
      }
      match = re_assign.exec(line);
      if (match) {
        kv[match[1]] = parseInt(match[2]);
      }
    }
    return kv;
  }

  async pivot(logfiles, testname) {
    let kfv_dict = {};
    for (let logfile of logfiles) {
      let kv = await this.parse(logfile);
      for (let key in kv) {
        let fv = kfv_dict[key];
        if (!fv) {
          kfv_dict[key] = fv = [];
        }
        fv.push({name:logfile, value:kv[key]});
      }
    }

    let kfv_list = Object.entries(kfv_dict);
    if (!kfv_list.length) {
      this.verbose(`${testname}: no counters collected`);
      return;
    }
  if (!this.options.all) {
      kfv_list = kfv_list.filter(kfv => {
        let fv_list = kfv[1];
        if (fv_list.length !== logfiles.length)
          return true;
        let value = fv_list[0].value;
        for (let i = 1; i < fv_list.length; i++) {
          if (fv_list[i].value !== value)
            return true;
        }
        return false;
      });
      if (!kfv_list.length) {
        this.verbose(`${testname}: no differences`);
        return;
      }
    }
    kfv_list = kfv_list.sort((a, b) => { return a[0] === b[0] ? 0 : (a[0] < b[0] ? -1 : 1); });
    if (testname)
      console.log(testname);
    for (let kfv of kfv_list) {
      let key = kfv[0];
      let fv_list = kfv[1];
      console.log(`  ${key}: ${fv_list.map(fv => {
        let logname = fv.name.replace(/\.log$/, '');
        return `${logname}=${fv.value}`;
      }).join(' ')}`);
    }
  }
};

(new PivotLog()).run();
